---
title: "Transformation"
format:
  revealjs:
    self-contained: true
    slide-number: true
    preview-links: auto
    logo: images/mia_logo.png
    footer: <https://microbiome.github.io/>
bibliography: references.bib
---

## Microbiome data

- **High variability** &mdash; feature abundances vary widely across samples
- **Zero-inflation** &mdash; many taxa absent in most samples
- **Compositionality** &mdash; only relative abundances observed; total counts per sample are arbitrary

::: {.notes}

- **High variability** → heteroscedasticity: the variance increases more than the mean. Abundant taxa have lots of variability.
- **Zero-inflation** → many features are absent in most samples, which complicates statistical modelling and increases sparsity of the data matrix.
- **Compositionality** → sequencing depth differs between samples; only *ratios* of features within a sample are meaningful, absolute counts are not.

:::

## Heteroscedasticity

```{r}
#| label: heteroscedasticity

library(ggplot2)

set.seed(42)

# Simulate heteroscedastic data: variance grows with x
x <- seq(1, 100, length.out = 200)
y <- 2 * x + rnorm(200, sd = x/2)  # noise increases with x

df1 <- data.frame(x, y)

ggplot(df1, aes(x, y)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  theme_classic()

```

::: {.notes}

The variance increases when abundance increases

:::

## Zero-inflation

```{r}
#| label: zero_inflation

library(miaViz)
data(GlobalPatterns)
plotHistogram(GlobalPatterns, assay.type = "counts")
```

::: {.notes}

Real microbiome data. Lots of zeroes.

:::

## Compositionality

- Numbers are dependent: if one increases, at least one must decrease
- Simplex space
  - If we know N-1 values, we know the last one
  - Constraint: all values positive and sum to a constant (often 1)

::: {.notes}

Standard statistics require that values are in Euclidean space.

Compositional data live in the simplex (compositional space), not Euclidean space (where subtractions, distances and variances make sense).

Results can be misleading without transformation.

:::

##

```{r}
#| label: show_compositional

library(ggplot2)
library(dplyr)
library(tidyr)

# Simulate absolute counts for 3 taxa across two samples
df_absolute <- tibble(
    Sample = c("Sample 1", "Sample 2"),
    Taxon_A = c(50, 150),  # Tribled
    Taxon_B = c(25, 25),   # Constant
    Taxon_C = c(25, 25)    # Constant
)

# Add relative abundances (simulate sequencing)
df_relative <- df_absolute %>%
    mutate(across(starts_with("Taxon"), ~ .x / rowSums(across(starts_with("Taxon"))))) %>%
    pivot_longer(cols = -Sample, names_to = "Taxon", values_to = "RelativeAbundance")

# Pivot absolute too for comparison
df_absolute_long <- df_absolute %>%
    pivot_longer(cols = -Sample, names_to = "Taxon", values_to = "Count")

# Plot 1: Absolute counts
p1 <- ggplot(df_absolute_long, aes(x = Sample, y = Count, fill = Taxon)) +
    geom_bar(stat = "identity", position = "stack") +
    labs(title = "Absolute counts", y = "Read count") +
    theme_minimal()

# Plot 2: Relative abundances
p2 <- ggplot(df_relative, aes(x = Sample, y = RelativeAbundance, fill = Taxon)) +
    geom_bar(stat = "identity", position = "fill") +
    labs(title = "Relative abundance", y = "Proportion") +
    theme_minimal()

library(patchwork)
# Combine plots and keep only one legend
p1 + p2 + plot_layout(guides = "collect") & theme(legend.position = "bottom")


```

::: {.notes}

Compositional bias.

:::

##

```{r}
#| label: show_ss
#| fig-width: 15
#| fig-height: 15

library(webshot2)
library(magick)

# Take the screenshot and save to a temporary file
tmpfile <- tempfile(fileext = ".png")

temp <- webshot(
    url = "https://www.frontiersin.org/journals/microbiology/articles/10.3389/fmicb.2017.02224/full",
    file = tmpfile,
    cliprect = c(0, 480, 1100, 520)
)
temp
```

## Goals of transformation

- Mitigate biases in abundances
- Make features comparable across samples
- Meet assumptions of downstream statistical analyses

::: {.notes}

- Transformations allow standard analyses like PCA, regression, correlation.
- Choose transformation depending on the problem: relative abundance, log, CLR, etc.

:::

## Relative abundance

$$
\text{X}_{ij} = \frac{\text{Count}_{ij}}{\sum_{k=1}^m \text{Count}_{ik}}
$$

*where*

* $i$ indexes the sample,
* $j$ indexes the taxon,
* $m$ is the total number of taxa.

::: {.notes}


- Library sizes differ between samples (sequencing depth varies), so raw counts are not directly comparable.
- Relative abundance converts counts to proportions within each sample, making samples comparable.
- Intuition: a relative abundance of 0.2 means “this taxon makes up 20% of this sample,” independent of total reads.

:::

## Log-transformed relative abundance

$$
\text{X}_{ij} = \log \left( \text{Relative abundance}_{ij} + \epsilon \right)
$$

*where*

* $\epsilon$ is a small pseudocount to avoid $\log(0)$.

::: {.notes}

Log-transform reduces skewness and makes differences among low-abundance taxa more visible, but a pseudocount is required to handle zeros.

:::

##

```{r}
#| label: relative_abundance

library(mia)
library(miaViz)
library(patchwork)

data(GlobalPatterns)
tse <- GlobalPatterns
tse <- transformAssay(tse, method = "relabundance")
tse <- transformAssay(tse, method = "relabundance", pseudocount = TRUE, name = "relabund")
tse <- transformAssay(tse, assay.type = "relabund", method = "log10", pseudocount = TRUE)


# Combine plots side by side
p1 <- plotHistogram(tse, assay.type = "counts") +
    xlab("Absolute abundance")
p2 <- plotHistogram(tse, assay.type = "relabundance") +
    xlab("Relative abundance")
p3 <- plotHistogram(tse, assay.type = "log10") +
    xlab("log10(relative abundance)")
p1 + p2 + p3
```

::: {.notes}

The data is still constrained to relative abundances (0-1), but now in log-scale.

Because the total is fixed, the numbers depend on each other.

If one goes up, at least one of the others must go down. This is called a constraint.

:::

## Centered log-ratio (CLR)

$$
\text{CLR}(x_i) = \log\left(\frac{x_i}{g(x)}\right),\quad
g(x) = \left(\prod_{j=1}^{D} x_j \right)^{1/D}
$$

- $x_i$: the $i$-th component of the composition  
- $g(x)$: geometric mean of the composition

::: {.notes}

- CLR removes compositional constraints and maps data from the simplex to Euclidean space.

1. Standard statistical tests assume Euclidean space, where subtraction and distances make sense.

2. Subtraction does not make sense on raw compositional data because only ratios between components carry information. --> How to convert ratios into subtraction? --> Using log-scale

3. Taking the log converts ratios into differences: log⁡(x/y)=log⁡(x)−log⁡(y)
so subtraction now has a meaningful interpretation.

4. The log-values still have an arbitrary baseline, so we center them around zero by subtracting the arithmetic mean of the logs, which is equivalent to dividing each component by the geometric mean of the original composition:

5. The result is a vector in Euclidean space with sum zero, suitable for standard analyses.

:::

##

$$
\text{Arithmetic mean} = \frac{2 + 8 + 32}{3} = \frac{42}{3} = 14
$$

$$
\text{Geometric mean} = \sqrt[3]{2 \cdot 8 \cdot 32} \\[2mm]
= \exp\Bigg( \frac{\log 2 + \log 8 + \log 32}{3} \Bigg) \\[2mm]
= \exp\Bigg( \frac{\log 2 + \log 2^3 + \log 2^5}{3} \Bigg) \\[2mm]
= \exp(3 \log 2) \\[1mm]
= 8
$$

::: {.notes}

There is nothing inherently special about the geometric mean — it is just the arithmetic mean in log-space, which is the space we are currently working in.

Dividing each value by the geometric mean is equivalent to subtracting the arithmetic mean of the logs.

This centers the data around zero in log-ratio space, making differences between components meaningful for standard statistical analyses.

:::

##

```{r}
#| label: centering

library(ggplot2)

set.seed(123)

# Original normal distribution with positive mean
x <- rnorm(1000, mean = 5, sd = 1)
df <- data.frame(x = x)

# Centered version (subtract mean)
x_centered <- x - mean(x)
df_centered <- data.frame(x = x_centered)

# Combine for plotting
df_plot <- rbind(
  data.frame(x = x, type = "Original"),
  data.frame(x = x_centered, type = "Centered")
)

# Plot
ggplot(df_plot, aes(x = x, y = ..density.., fill = type)) +
  geom_density(alpha = 0.5, position = "identity", bins = 30, show.legend = FALSE) +
  geom_vline(xintercept = mean(x), linetype = "dashed", color = "blue") +
  geom_vline(xintercept = mean(x_centered), linetype = "dashed", color = "red") +
  annotate("segment", x = mean(x), xend = mean(x_centered), y = 0.15, yend = 0.15,
           arrow = arrow(length = unit(0.3,"cm")), color = "black") +
  annotate("text", x = (mean(x)+mean(x_centered))/2, y = 0.17, label = "Centering", hjust = 0.5) +
  labs(title = "", x = "x", y = "Density") +
  theme_minimal() +
  theme(legend.position = "none")

```

::: {.notes}

Centering means that we subtract mean from each value to get the distribution centered to 0. Because we use log-scale, we have to use suitable mean (geometric mean aka arithmetic mean in log-scale).

:::

## Centered log-ratio (CLR)

$$
\text{CLR}(x_i) \;=\; \log\left(\frac{x_i}{g(x)}\right) \\[2mm]
= \log(x_i) - \log(g(x)) \\[2mm]
= \log(x_i) - \frac{1}{D}\sum_{j=1}^{D}\log(x_j)
$$

::: {.notes}

- Take a logarithm of the values --> ratios become subtraction which is what we want in Euclidean space
- Center values to mean 0

:::

## Interpretation:

- Positive CLR → feature is more abundant than the sample’s average
- Negative CLR → feature is less abundant than the sample’s average
- Magnitude → how strongly the feature deviates from the average
  - On a log scale: CLR = 1 → ~2.7× average
  - CLR = 2 → ~7.4× average
  - CLR = −1 → ~0.37× average

::: {.notes}

- CLR values show how each feature compares to the sample’s geometric mean.
- Positive = enriched, Negative = depleted.
- Magnitude gives a fold-change interpretation on a log scale.

:::

## Centered log-ratio (CLR)

- Removes compositional constraints (constant sum)
- Values centered around zero, symmetric
- Allows standard statistical tools (PCA, correlations)
- [Debate on whether it is necessary in DA](https://www.biorxiv.org/content/10.1101/2025.02.13.638109v1.full.pdf){preview-link="true"}

::: {.notes}

- CLR is widely used in microbiome data analysis because it removes compositional constraints and often makes data more normally distributed.

- However, recent benchmark studies highlight some limitations in differential abundance (DA) analysis:
  - Can lack sensitivity
  - May produce paradoxical results in low-diversity microbiomes
- CLR values are harder to interpret than relative abundances because each value is dependent on the other features in the sample

Despite this, CLR remains a standard, especially for methods that assume Euclidean space.

:::

##

```{r}
#| label: clr

library(mia)
library(miaViz)
library(patchwork)

data(GlobalPatterns)
tse <- GlobalPatterns
tse <- transformAssay(tse, method = "rclr")

# Combine plots side by side
p1 <- plotHistogram(tse, assay.type = "counts") +
    xlab("Absolute abundance")
p2 <- plotHistogram(tse, assay.type = "rclr") +
    xlab("CLR abundance")
p1 + p2
```

::: {.notes}

Makes the data more normally distributed. Distributed around zero. Without constrains (goes from negative infinity to positive)

:::

## Demonstration

```r
library(mia)

tse <- transformAssay(tse, method = "relabundance")
print(tse)
```

```{r}
#| label: transformation

library(mia)
data(GlobalPatterns)
tse <- GlobalPatterns
tse <- transformAssay(tse, method = "relabundance")
tse
```

## Exercises

From [OMA online book, Chapter 12: Transformation](https://microbiome.github.io/OMA/docs/devel/pages/agglomeration.html)

- All exercises

## References
