---
title: "Ordination"
format:
  revealjs:
    self-contained: true
    slide-number: true
    preview-links: auto
    logo: images/mia_logo.png
    footer: <https://microbiome.github.io/>
date: last-modified
date-format: full
bibliography: references.bib
---

## Ordination {.smaller}

- Reduces high-dimensional data to a few informative axes
- Projects samples into lower-dimensional space while preserving distances or variance
- Helps identify patterns, clusters, and gradients across samples

::: {.notes}

Ordination visualizes high-dimensional relationships in 2D or 3D space.
Clusters indicate similarity in community composition.

:::

##

```{r}
# Load required libraries
library(ggplot2)

set.seed(42)
n_samples <- 50

# Cluster 1: diagonal in X-Y-Z space
cluster1 <- data.frame(
  Taxon_X = rnorm(n_samples, mean = 2, sd = 0.5),
  Taxon_Y = rnorm(n_samples, mean = 2, sd = 0.5),
  Taxon_Z = rnorm(n_samples, mean = 2, sd = 0.5),
  Cluster = "A"
)

# Cluster 2: diagonal in opposite direction
cluster2 <- data.frame(
  Taxon_X = rnorm(n_samples, mean = -2, sd = 1),
  Taxon_Y = rnorm(n_samples, mean = -2, sd = 2),
  Taxon_Z = rnorm(n_samples, mean = -2, sd = 2),
  Cluster = "B"
)

# Cluster 3: orthogonal diagonal
cluster3 <- data.frame(
  Taxon_X = rnorm(n_samples, mean = 2, sd = 1),
  Taxon_Y = rnorm(n_samples, mean = -2, sd = 2),
  Taxon_Z = rnorm(n_samples, mean = 2, sd = 1),
  Cluster = "C"
)

# Combine
df <- rbind(cluster1, cluster2, cluster3)
# install.packages("plotly") if needed
library(plotly)

# Use the previous df with a "Cluster" column
plot_ly(
  df,
  x = ~Taxon_X,
  y = ~Taxon_Y,
  z = ~Taxon_Z,
  color = ~Cluster,  # <-- this determines color
  colors = c("A" = "steelblue", "B" = "forestgreen", "C" = "orange"),
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 4)
)
```

::: {.notes}

This is now 3 dimensional plot. The idea is to rotate the data so that it maximizes the information in 2D.

:::

##

![](images/hand_shadow.webp){fig-align="center" width="330"}

::: {.notes}

Illustration. Hand is 3d, shadow is 2d. The goal is to rotate hand so that it resembles hand in 2d --> information preserved even though dimensionality is lower.

:::

## Ordination methods

- PCA, PCoA/MDS, RDA, ...
- Euclidean vs non-Euclidean
- Unsupervised vs supervised

```{r}
#| label: illustration

library(ggplot2)

# Define two points
A <- c(x = 2, y = 3)
B <- c(x = 6, y = 7)

# Data frame of points
points_df <- data.frame(
  Sample = c("A", "B"),
  x = c(A["x"], B["x"]),
  y = c(A["y"], B["y"])
)

# Data for triangle lines (legs)
triangle_df <- data.frame(
  x = c(A["x"], A["x"], B["x"]),
  y = c(A["y"], B["y"], B["y"])
)

# Compute distance
dx <- B["x"] - A["x"]
dy <- B["y"] - A["y"]
euclid <- sqrt(dx^2 + dy^2)

# Plot
ggplot() +
  # Points
  geom_point(data = points_df, aes(x = x, y = y), size = 5, color = "black") +
  geom_text(data = points_df, aes(x = x, y = y, label = Sample),
            vjust = -1.2, size = 6) +

  # Triangle lines
  geom_path(data = triangle_df, aes(x = x, y = y), color = "gray50", linetype = "dashed") +

  # Hypotenuse (Euclidean distance)
  geom_segment(aes(x = A["x"], y = A["y"],
                   xend = B["x"], yend = B["y"]),
               color = "blue", size = 1.2,
               arrow = arrow(length = unit(0.2, "cm"))) +

  # Distance labels
  annotate("text", x = (A["x"] + B["x"])/2 - 0.3, y = (A["y"] + B["y"])/2 + 0.4,
           label = paste0("√(", dx, "^2 + ", dy, "^2) = ", round(euclid, 2)),
           color = "blue", fontface = "italic", size = 5) +
  annotate("text", x = A["x"] + dx/2, y = A["y"] - 0.5,
           label = paste("Δx =", dx), size = 5) +
  annotate("text", x = A["x"] - 0.7, y = A["y"] + dy/2,
           label = paste("Δy =", dy), size = 5) +

  coord_fixed() +
  xlim(1, 7.5) + ylim(2, 8) +
  labs(
       x = "",
       y = "") +
  theme_minimal(base_size = 14)

```

::: {.notes}

Different techniques depending on goal. PCA is the most basic one and commonly used. However, microbiome
data has unique nature that must be taken into account when applying.

:::

## Principal component analysis (PCA)

- Unsupervised ordination method
- Euclidean distance
- Aitchison distance: CLR + Euclidean distance

```{r}
#| label: pca
#| fig-width: 6
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020
# Transform data
tse <- transformAssay(tse, method = "clr", pseudocount = 1L)

library(scater)

tse <- runPCA(
    tse,
    assay.type = "clr"
)

plotReducedDim(tse, "PCA", colour_by = "patient_status")
```

::: {.notes}

CLR must be applied. Preserves variance.

:::

## Principal coordinate analysis (PCoA)

- Multidimensional scaling (MDS)
- Unsupervised ordination method
- Any dissimilarity metric (e.g., Bray-Curtis dissimilarity)

```{r}
#| label: mds
#| fig-width: 6
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020

library(scater)

tse <- addMDS(
    tse,
    method = "unifrac"
)

plotReducedDim(tse, "MDS", colour_by = "patient_status")
```

::: {.notes}

Extension to PCA. Preserves distances. If Euclidean distance is chosen, same as PCA.

:::

## Redundancy analysis (RDA)

- Supervised ordination method
- Find variance explained by sample metadata

```{r}
#| label: rda
#| fig-width: 6
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020

tse <- transformAssay(tse, method = "relabundance")

tse <- addRDA(
    tse,
    formula = . ~ cohort + patient_status,
    assay.type = "relabundance",
    method = "bray"
)

library(miaViz)
plotRDA(tse, "RDA", colour_by = "patient_status")
```

::: {.notes}

Takes into account covariates. Aims to find variance explained by covariates.

Distance-based extension (PCoA with covariates)

If no covariates are specified, equals to PCA.

:::

## Matrix Decomposition {.smaller}

- Conceptual basis of ordination: decompose sample × taxa matrix

$$
X = U \Sigma V^T
$$

- **UΣ:** sample coordinates in reduced space
- **Σ**: importance of each axis
- **V:** taxa contributions

```{r}
#| label: pca2
#| fig-width: 14
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020
# Transform data
tse <- transformAssay(tse, method = "clr", pseudocount = 1L)

library(scater)

tse <- runPCA(
    tse,
    assay.type = "clr"
)

library(patchwork)
p1 <- plotReducedDim(tse, "PCA", colour_by = "patient_status")
p2 <- plotLoadings(tse, "PCA", ncomponents = 2, layout = "lollipop") + labs(y = "", x = "")
p1 + p2 + plot_layout(widths = c(0.75, 1.25))
```

::: {.notes}

Matrix decomposition is the conceptual basis of ordination.
Only in Euclidean distances the loadings are easily interpretable.

:::


## Demonstration

## {auto-animate="true"}

```r
library(mia)
library(scater)

# Apply transformation
tse <- transformAssay(tse, method = "rclr")
```

## {auto-animate="true"}

```r
library(mia)
library(scater)

# Apply transformation
tse <- transformAssay(tse, method = "rclr")
# Apply PCA
tse <- runPCA(tse, assay.type = "rclr")
```

## {auto-animate="true"}

```r
library(mia)
library(scater)

# Apply transformation
tse <- transformAssay(tse, method = "rclr")
# Apply PCA
tse <- runPCA(tse, assay.type = "clr")
# Visualize
plotReducedDim(tse, "PCA", colour_by = "patient_status")
```

```{r}
#| label: demo

library(mia)
data("Tengeler2020")
tse <- Tengeler2020
# Transform data
tse <- transformAssay(tse, method = "clr", pseudocount = 1L)

library(scater)

tse <- runPCA(
    tse,
    assay.type = "clr"
)

plotReducedDim(tse, "PCA", colour_by = "patient_status")
```

## Exercises

From [OMA online book, Chapter 15: Community similarity](https://microbiome.github.io/OMA/docs/devel/pages/community_similarity.html)

- Exercise 1
- Exercise 2
- Exercise 3

## References
