---
title: "Ordination"
format:
  revealjs:
    self-contained: true
    slide-number: true
    preview-links: auto
    logo: images/mia_logo.png
    footer: <https://microbiome.github.io/>
date: last-modified
date-format: full
bibliography: references.bib
---

## Ordination {.smaller}

- Reduces high-dimensional data to a few informative axes
- Projects samples into lower-dimensional space while preserving distances or variance
- Helps identify patterns, clusters, and gradients across samples

::: {.notes}

Ordination visualizes high-dimensional relationships in 2D or 3D space.
Clusters indicate similarity in community composition.

:::

##

```{r}
#| label: ordination_illustration
# Load required libraries
library(ggplot2)

set.seed(42)
n_samples <- 50

# Cluster 1: diagonal in X-Y-Z space
cluster1 <- data.frame(
  Taxon_X = rnorm(n_samples, mean = 2, sd = 0.5),
  Taxon_Y = rnorm(n_samples, mean = 2, sd = 0.5),
  Taxon_Z = rnorm(n_samples, mean = 2, sd = 0.5),
  Cluster = "A"
)

# Cluster 2: diagonal in opposite direction
cluster2 <- data.frame(
  Taxon_X = rnorm(n_samples, mean = -2, sd = 1),
  Taxon_Y = rnorm(n_samples, mean = -2, sd = 2),
  Taxon_Z = rnorm(n_samples, mean = -2, sd = 2),
  Cluster = "B"
)

# Cluster 3: orthogonal diagonal
cluster3 <- data.frame(
  Taxon_X = rnorm(n_samples, mean = 2, sd = 1),
  Taxon_Y = rnorm(n_samples, mean = -2, sd = 2),
  Taxon_Z = rnorm(n_samples, mean = 2, sd = 1),
  Cluster = "C"
)

# Combine
df <- rbind(cluster1, cluster2, cluster3)
# install.packages("plotly") if needed
library(plotly)

# Use the previous df with a "Cluster" column
plot_ly(
  df,
  x = ~Taxon_X,
  y = ~Taxon_Y,
  z = ~Taxon_Z,
  color = ~Cluster,  # <-- this determines color
  colors = c("A" = "steelblue", "B" = "forestgreen", "C" = "orange"),
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 4)
)
```

::: {.notes}

Rotate 3 dimensional plot so that it maximizes the information in 2D. Illustrate the idea of PCA.

This is now 3 dimensional plot. The idea is to rotate the data so that it maximizes the information in 2D.

:::

##

![](images/hand_shadow.webp){fig-align="center" width="330"}

::: {.notes}

Illustration. Hand is 3d, shadow is 2d. The goal is to rotate hand so that it resembles hand in 2d --> information preserved even though dimensionality is lower.

:::

## Ordination methods

- PCA, PCoA/MDS, RDA, ...
- Euclidean vs non-Euclidean
- Unsupervised vs supervised

```{r}
#| label: illustration

library(ggplot2)

# Define two points
A <- c(x = 2, y = 3)
B <- c(x = 6, y = 7)

# Data frame of points
points_df <- data.frame(
  Sample = c("A", "B"),
  x = c(A["x"], B["x"]),
  y = c(A["y"], B["y"])
)

# Data for triangle lines (legs)
triangle_df <- data.frame(
  x = c(A["x"], A["x"], B["x"]),
  y = c(A["y"], B["y"], B["y"])
)

# Compute distance
dx <- B["x"] - A["x"]
dy <- B["y"] - A["y"]
euclid <- sqrt(dx^2 + dy^2)

# Plot
ggplot() +
  # Points
  geom_point(data = points_df, aes(x = x, y = y), size = 5, color = "black") +
  geom_text(data = points_df, aes(x = x, y = y, label = Sample),
            vjust = -1.2, size = 6) +

  # Triangle lines
  geom_path(data = triangle_df, aes(x = x, y = y), color = "gray50", linetype = "dashed") +

  # Hypotenuse (Euclidean distance)
  geom_segment(aes(x = A["x"], y = A["y"],
                   xend = B["x"], yend = B["y"]),
               color = "blue", size = 1.2,
               arrow = arrow(length = unit(0.2, "cm"))) +

  # Distance labels
  annotate("text", x = (A["x"] + B["x"])/2 - 0.3, y = (A["y"] + B["y"])/2 + 0.4,
           label = paste0("√(", dx, "^2 + ", dy, "^2) = ", round(euclid, 2)),
           color = "blue", fontface = "italic", size = 5) +
  annotate("text", x = A["x"] + dx/2, y = A["y"] - 0.5,
           label = paste("Δx =", dx), size = 5) +
  annotate("text", x = A["x"] - 0.7, y = A["y"] + dy/2,
           label = paste("Δy =", dy), size = 5) +

  coord_fixed() +
  xlim(1, 7.5) + ylim(2, 8) +
  labs(
       x = "",
       y = "") +
  theme_minimal(base_size = 14)

```

::: {.notes}

Different techniques depending on goal. PCA is the most basic one and commonly used. However, microbiome
data has unique nature that must be taken into account when applying.

Transformation lecture...

There are different ways to calculate distance or dissimilarity between samples.
We can use different measurements. Euclidean is the simplest (elementary school distance, real distance).
But there are also other methods.

In ML, unsupervised means that the method does not take into account sample information (it odes it blindfoldedly).
After applying the method, we can check if the results associates with some metadata, for instance, diagnosis.
If it does, it is very robust indication of association.

In supervised ML, we specifically say to model to take the diagnosis information
into account.
:::

## Principal component analysis (PCA)

- Unsupervised ordination method
- Euclidean distance
- Aitchison distance: CLR + Euclidean distance

```{r}
#| label: pca
#| fig-width: 6
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020
# Transform data
tse <- transformAssay(tse, method = "clr", pseudocount = 1L)

library(scater)

tse <- runPCA(
    tse,
    assay.type = "clr"
)

plotReducedDim(tse, "PCA", colour_by = "patient_status")
```

::: {.notes}

CLR must be applied. Preserves variance.

After we run the PCA, we can visualize results. Each point here is a sample.
Then we can also color the points and check if the results of PCA, associates
with sample grouping.

:::

## Principal coordinate analysis (PCoA)

- Multidimensional scaling (MDS)
- Unsupervised ordination method
- Any dissimilarity metric (e.g., Bray-Curtis dissimilarity)

```{r}
#| label: mds
#| fig-width: 6
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020

library(scater)

tse <- addMDS(
    tse,
    method = "unifrac"
)

plotReducedDim(tse, "MDS", colour_by = "patient_status")
```

::: {.notes}

Extension to PCA.
Preserves distances. If Euclidean distance is chosen, same as PCA.

:::

## Redundancy analysis (RDA)

- Supervised ordination method
- Find variance explained by sample metadata

```{r}
#| label: rda
#| fig-width: 6
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020

tse <- transformAssay(tse, method = "relabundance")

tse <- addRDA(
    tse,
    formula = . ~ cohort + patient_status,
    assay.type = "relabundance",
    method = "bray"
)

library(miaViz)
plotRDA(tse, "RDA", colour_by = "patient_status")
```

::: {.notes}

Takes into account covariates. Aims to find variance explained by covariates.

Distance-based extension (PCoA with covariates)

If no covariates are specified, equals to PCA.

:::

## Matrix Decomposition {.smaller}

- Conceptual basis of ordination: decompose sample × taxa matrix

$$
X = U \Sigma V^T
$$

- **UΣ:** sample coordinates in reduced space
- **Σ**: importance of each axis
- **V:** taxa contributions

```{r}
#| label: pca2
#| fig-width: 14
#| fig-height: 3

library(mia)
data("Tengeler2020")
tse <- Tengeler2020
# Transform data
tse <- transformAssay(tse, method = "clr", pseudocount = 1L)

library(scater)

tse <- runPCA(
    tse,
    assay.type = "clr"
)

library(patchwork)
p1 <- plotReducedDim(tse, "PCA", colour_by = "patient_status")
p2 <- plotLoadings(tse, "PCA", ncomponents = 2, layout = "lollipop") + labs(y = "", x = "")
p1 + p2 + plot_layout(widths = c(0.75, 1.25))
```

::: {.notes}

Matrix decomposition is the conceptual basis of ordination.
Only in Euclidean distances the loadings are easily interpretable.

:::


## Demonstration

## {auto-animate="true"}

```r
library(mia)
library(scater)

# Apply transformation
tse <- transformAssay(tse, method = "rclr")
```

## {auto-animate="true"}

```r
library(mia)
library(scater)

# Apply transformation
tse <- transformAssay(tse, method = "rclr")
# Apply PCA
tse <- runPCA(tse, assay.type = "rclr")
```

## {auto-animate="true"}

```r
library(mia)
library(scater)

# Apply transformation
tse <- transformAssay(tse, method = "rclr")
# Apply PCA
tse <- runPCA(tse, assay.type = "clr")
# Visualize
plotReducedDim(tse, "PCA", colour_by = "patient_status")
```

```{r}
#| label: demo

library(mia)
data("Tengeler2020")
tse <- Tengeler2020
# Transform data
tse <- transformAssay(tse, method = "clr", pseudocount = 1L)

library(scater)

tse <- runPCA(
    tse,
    assay.type = "clr"
)

plotReducedDim(tse, "PCA", colour_by = "patient_status")
```

## Exercises

From [OMA online book, Chapter 15: Community similarity](https://microbiome.github.io/OMA/docs/devel/pages/community_similarity.html)

- Exercise 1
- Exercise 2
- Exercise 3

## References
